import express from 'express';
import { createProxyMiddleware } from 'http-proxy-middleware';
import cors from 'cors';
import bodyParser from 'body-parser';
import axios from 'axios';
import { createServer } from 'node:http';
import path from 'path';
import fs from 'fs';
import dotenv from 'dotenv';
import rateLimit from 'express-rate-limit';
import helmet from 'helmet';
import { initializeAuth, shutdownAuth } from './auth/index.js';
import middleware from './auth/middleware.js';
const { authenticate: authenticateToken, authorize: requirePermission, requireSameCompany: requireCompanyAccess } = middleware;
// authRoutes rimosso - non necessario nel proxy server
import prisma from './config/prisma-optimization.js';

// Import logging and error handling
import { logger, httpLogger, logAudit } from './utils/logger.js';
import { globalErrorHandler, notFoundHandler } from './middleware/errorHandler.js';
import loadBalancer from './utils/loadBalancer.js';

// Initialize Prisma client
// Inizializzazione Prisma con gestione errori
try {
  console.log('✅ Prisma client initialized successfully');
} catch (error) {
  console.error('❌ Failed to initialize Prisma client:', error);
  throw new Error('Database connection failed');
}

// Load environment variables
dotenv.config();

const app = express();
const PORT = process.env.PROXY_PORT || process.env.PORT || 4006;

console.log('🔧 Environment variables loaded:');
console.log('   PROXY_PORT:', process.env.PROXY_PORT);
console.log('   Using PORT:', PORT);

// CORS configuration moved inside initializeServer function

console.log('✅ CORS will be configured inside initializeServer function');
// Gestione degli errori di avvio
process.on('uncaughtException', (error) => {
  console.error('❌ Uncaught Exception:', error);
  logger.error('Uncaught Exception', { service: 'proxy-server', error: error.message, stack: error.stack });
  process.exit(1);
});

// Gestione degli errori nelle promise non gestite
process.on('unhandledRejection', (reason, promise) => {
  logger.error('Unhandled Promise Rejection', { service: 'proxy-server', reason, promise });
  process.exit(1);
});

// Async initialization function
async function initializeServer() {
  try {
    // CORS configuration removed - handled by specific route handlers
    console.log('✅ CORS will be handled by specific route handlers');

    // Initialize authentication system
    await initializeAuth();
    logger.info('Authentication system initialized in Proxy Server', { service: 'proxy-server', port: PORT });

    // Handle OPTIONS requests for /api/auth manually - MUST be FIRST to avoid middleware interference
    app.options('/api/auth/*', (req, res) => {
      console.log('🚨 [AUTH OPTIONS /*] Handling OPTIONS request for:', req.originalUrl);
      res.header('Access-Control-Allow-Origin', 'http://localhost:5173');
      res.header('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE,OPTIONS');
      res.header('Access-Control-Allow-Headers', 'Content-Type,Authorization,X-Requested-With,x-tenant-id,X-Tenant-ID,cache-control,pragma,expires');
      res.header('Access-Control-Allow-Credentials', 'true');
      res.status(200).end();
    });
    
    app.options('/api/auth/verify', (req, res) => {
      console.log('🚨 [AUTH OPTIONS /verify] Handling OPTIONS request for:', req.originalUrl);
      res.header('Access-Control-Allow-Origin', 'http://localhost:5173');
      res.header('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE,OPTIONS');
      res.header('Access-Control-Allow-Headers', 'Content-Type,Authorization,X-Requested-With,x-tenant-id,X-Tenant-ID,cache-control,pragma,expires');
      res.header('Access-Control-Allow-Credentials', 'true');
      res.status(200).end();
    });
    
    app.options('/api/auth/login', (req, res) => {
      console.log('🚨 [AUTH OPTIONS /login] Handling OPTIONS request for:', req.originalUrl);
      res.header('Access-Control-Allow-Origin', 'http://localhost:5173');
      res.header('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE,OPTIONS');
      res.header('Access-Control-Allow-Headers', 'Content-Type,Authorization,X-Requested-With,x-tenant-id,X-Tenant-ID,cache-control,pragma,expires');
      res.header('Access-Control-Allow-Credentials', 'true');
      res.status(200).end();
    });
    
    app.options('/api/auth/logout', (req, res) => {
      console.log('🚨 [AUTH OPTIONS /logout] Handling OPTIONS request for:', req.originalUrl);
      res.header('Access-Control-Allow-Origin', 'http://localhost:5173');
      res.header('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE,OPTIONS');
      res.header('Access-Control-Allow-Headers', 'Content-Type,Authorization,X-Requested-With,x-tenant-id,X-Tenant-ID,cache-control,pragma,expires');
      res.header('Access-Control-Allow-Credentials', 'true');
      res.status(200).end();
    });
    
    app.options('/api/auth/refresh', (req, res) => {
      console.log('🚨 [AUTH OPTIONS /refresh] Handling OPTIONS request for:', req.originalUrl);
      res.header('Access-Control-Allow-Origin', 'http://localhost:5173');
      res.header('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE,OPTIONS');
      res.header('Access-Control-Allow-Headers', 'Content-Type,Authorization,X-Requested-With,x-tenant-id,X-Tenant-ID,cache-control,pragma,expires');
      res.header('Access-Control-Allow-Credentials', 'true');
      res.status(200).end();
    });
    
    // Handle OPTIONS for /api/tenants to avoid rate limiting on CORS preflight
    app.options('/api/tenants', (req, res) => {
      console.log('🚨 [TENANTS OPTIONS] Handling OPTIONS request for:', req.originalUrl);
      res.header('Access-Control-Allow-Origin', 'http://localhost:5173');
      res.header('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE,OPTIONS');
      res.header('Access-Control-Allow-Headers', 'Content-Type,Authorization,X-Requested-With,x-tenant-id,X-Tenant-ID,cache-control,pragma,expires');
      res.header('Access-Control-Allow-Credentials', 'true');
      res.status(200).end();
    });
    
    app.options('/api/tenants/*', (req, res) => {
      console.log('🚨 [TENANTS OPTIONS /*] Handling OPTIONS request for:', req.originalUrl);
      res.header('Access-Control-Allow-Origin', 'http://localhost:5173');
      res.header('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE,OPTIONS');
      res.header('Access-Control-Allow-Headers', 'Content-Type,Authorization,X-Requested-With,x-tenant-id,X-Tenant-ID,cache-control,pragma,expires');
      res.header('Access-Control-Allow-Credentials', 'true');
      res.status(200).end();
    });
    
    // Handle OPTIONS for /api/roles to avoid rate limiting on CORS preflight
    app.options('/api/roles', (req, res) => {
      console.log('🚨 [ROLES OPTIONS] Handling OPTIONS request for:', req.originalUrl);
      res.header('Access-Control-Allow-Origin', 'http://localhost:5173');
      res.header('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE,OPTIONS');
      res.header('Access-Control-Allow-Headers', 'Content-Type,Authorization,X-Requested-With,x-tenant-id,X-Tenant-ID,cache-control,pragma,expires');
      res.header('Access-Control-Allow-Credentials', 'true');
      res.status(200).end();
    });
    
    app.options('/api/roles/*', (req, res) => {
      console.log('🚨 [ROLES OPTIONS /*] Handling OPTIONS request for:', req.originalUrl);
      res.header('Access-Control-Allow-Origin', 'http://localhost:5173');
      res.header('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE,OPTIONS');
      res.header('Access-Control-Allow-Headers', 'Content-Type,Authorization,X-Requested-With,x-tenant-id,X-Tenant-ID,cache-control,pragma,expires');
      res.header('Access-Control-Allow-Credentials', 'true');
      res.status(200).end();
    });
    
    console.log('✅ OPTIONS handlers configured for auth, tenants and roles endpoints');

    // Middleware di sicurezza
    app.use(helmet({
      contentSecurityPolicy: {
        directives: {
          defaultSrc: ["'self'"],
          styleSrc: ["'self'", "'unsafe-inline'", "https:"],
          scriptSrc: ["'self'"],
          imgSrc: ["'self'", "data:"],
        },
      },
    }));

    // HTTP request logging
    app.use(httpLogger);
    
    // DEBUG: Middleware per tracciare modifiche al path
    app.use((req, res, next) => {
      console.log('🔍 [PATH TRACE] Original:', {
        method: req.method,
        url: req.url,
        path: req.path,
        originalUrl: req.originalUrl,
        baseUrl: req.baseUrl
      });
      
      // Verifica se la richiesta è per /api/roles
      if (req.originalUrl.includes('/api/roles')) {
        console.log('🚨 [ROLES DEBUG] Request detected for /api/roles');
      }
      
      next();
    });

    // DEBUG: Middleware specifico per tracciare richieste /api/user
    app.use('/api/user', (req, res, next) => {
      console.log('🔍 [API USER TRACE]:', {
        method: req.method,
        url: req.url,
        path: req.path,
        originalUrl: req.originalUrl,
        baseUrl: req.baseUrl
      });
      next();
    });

    // Rate limiting configuration
    const generalLimiter = rateLimit({
      windowMs: 15 * 60 * 1000, // 15 minutes
      max: 100, // Limit each IP to 100 requests per windowMs
      message: {
        error: 'Too many requests from this IP',
        code: 'RATE_LIMIT_EXCEEDED',
        retryAfter: '15 minutes'
      },
      standardHeaders: true,
      legacyHeaders: false,
      // Skip rate limiting for OPTIONS requests (CORS preflight)
      skip: (req) => req.method === 'OPTIONS',
      handler: (req, res) => {
        logger.warn('Rate limit exceeded', {
          service: 'proxy-server',
          ip: req.ip,
          path: req.path,
          userAgent: req.get('User-Agent')
        });
        res.status(429).json({
          error: 'Too many requests from this IP',
          code: 'RATE_LIMIT_EXCEEDED',
          retryAfter: '15 minutes'
        });
      }
    });

    // Stricter rate limiting for API endpoints
    const apiLimiter = rateLimit({
      windowMs: 15 * 60 * 1000, // 15 minutes
      max: process.env.NODE_ENV === 'development' ? 1000 : 200, // Higher limit for development
      message: {
        error: 'Too many API requests from this IP',
        code: 'API_RATE_LIMIT_EXCEEDED',
        retryAfter: '15 minutes'
      },
      standardHeaders: true,
      legacyHeaders: false,
      // Skip rate limiting for OPTIONS requests (CORS preflight) and tenant endpoints
      skip: (req) => {
        if (req.method === 'OPTIONS') return true;
        // Skip rate limiting for tenant endpoints (critical endpoint)
        if (req.path.includes('/api/tenants') || req.originalUrl.includes('/api/tenants')) return true;
        return false;
      },
      handler: (req, res) => {
        logger.warn('API rate limit exceeded', {
          service: 'proxy-server',
          ip: req.ip,
          path: req.path,
          userAgent: req.get('User-Agent')
        });
        res.status(429).json({
          error: 'Too many API requests from this IP',
          code: 'API_RATE_LIMIT_EXCEEDED',
          retryAfter: '15 minutes'
        });
      }
    });

    // Debug middleware removed - proxy working correctly
    // DUPLICATED MIDDLEWARE REMOVED - helmet, httpLogger and debug middleware already applied above

    // Apply general rate limiting to all requests (except OPTIONS, /api/tenants, and /api/roles)
    app.use((req, res, next) => {
      // Skip rate limiting for OPTIONS requests (CORS preflight)
      if (req.method === 'OPTIONS') {
        console.log('🔍 [RATE LIMITER] Skipping rate limiting for OPTIONS request:', req.originalUrl);
        return next();
      }
      // Skip rate limiting for /api/tenants requests (critical endpoint)
      if (req.originalUrl.includes('/api/tenants')) {
        console.log('🔍 [RATE LIMITER] Skipping rate limiting for /api/tenants request:', req.originalUrl);
        return next();
      }
      // Skip rate limiting for /api/roles requests (critical endpoint)
      if (req.originalUrl.includes('/api/roles')) {
        console.log('🔍 [RATE LIMITER] Skipping rate limiting for /api/roles request:', req.originalUrl);
        return next();
      }
      // Apply rate limiting for all other requests
      generalLimiter(req, res, next);
    });

    // Configurazione dei target per i server
    const apiServerTarget = 'http://127.0.0.1:4001';
    const documentsServerTarget = 'http://127.0.0.1:4002';

    // Register servers with load balancer
    loadBalancer.registerServer('api-primary', {
      url: 'http://127.0.0.1:4001',
      weight: 1,
      type: 'api'
    });

    loadBalancer.registerServer('documents-primary', {
      url: 'http://127.0.0.1:4002',
      weight: 1,
      type: 'documents'
    });

    // Start health checks
    loadBalancer.startHealthChecks();

    // Configurazione per le chiamate API dirette
    const API_PORT = 4001;
    const API_HOST = '127.0.0.1';
    const API_URL = `http://${API_HOST}:${API_PORT}`;

    // Middleware per il logging delle richieste
    app.use((req, res, next) => {
      // Rimuoviamo il logging per migliorare le prestazioni
      next();
    });

    // CRITICAL FIX: Body parser RIMOSSO globalmente perché interferisce con http-proxy-middleware
    // Il body parser consuma il body della richiesta e il proxy non può più accedervi
    // Verrà applicato solo agli endpoint locali che ne hanno bisogno
    // app.use(bodyParser.json({ limit: '50mb' }));
    // app.use(bodyParser.urlencoded({ extended: true, limit: '50mb' }));

    // Health check endpoint - MUST be before proxy middleware
    app.get('/health', async (req, res) => {
      try {
        // Check API server health
        const apiResponse = await axios.get(`${apiServerTarget}/health`, { timeout: 5000 });
        res.json(apiResponse.data);
      } catch (error) {
        logger.error('Health check failed', { service: 'proxy-server', error: error.message });
        res.status(503).json({
          status: 'unhealthy',
          error: 'API server not responding',
          timestamp: new Date().toISOString()
        });
      }
    });

    // Le richieste /auth vengono gestite dal middleware /api generale
    
    // Routing locale per courses (gestito direttamente dal proxy)
    app.get('/courses', async (req, res) => {
      const { search } = req.query;
      let where = {};
      if (search) {
        where = {
          title: {
            contains: search,
            mode: 'insensitive',
          },
        };
      }
      const courses = await prisma.course.findMany({ where });
      res.json(courses);
    });

    app.get('/courses/:id', async (req, res) => {
      const course = await prisma.course.findUnique({ where: { id: req.params.id } });
      if (!course) return res.status(404).json({ error: 'Not found' });
      res.json(course);
    });

    app.post('/courses', bodyParser.json({ limit: '50mb' }), bodyParser.urlencoded({ extended: true, limit: '50mb' }), async (req, res) => {
      try {
        const { price, ...inputData } = req.body;
        const sanitizedData = { ...inputData };
        
        if ('validityYears' in sanitizedData) {
          const num = Number(sanitizedData.validityYears);
          sanitizedData.validityYears = !isNaN(num) ? Math.round(num) : null;
        }
        
        if ('maxPeople' in sanitizedData) {
          const num = Number(sanitizedData.maxPeople);
          sanitizedData.maxPeople = !isNaN(num) ? Math.round(num) : null;
        }
        
        if ('pricePerPerson' in sanitizedData) {
          const num = Number(sanitizedData.pricePerPerson);
          sanitizedData.pricePerPerson = !isNaN(num) ? num : null;
        }

        let course;
        if (sanitizedData.code) {
          course = await prisma.course.upsert({
            where: { code: sanitizedData.code },
            update: sanitizedData,
            create: sanitizedData
          });
        } else {
          course = await prisma.course.create({ data: sanitizedData });
        }

        res.status(201).json(course);
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    app.put('/courses/:id', bodyParser.json({ limit: '50mb' }), bodyParser.urlencoded({ extended: true, limit: '50mb' }), async (req, res) => {
      try {
        const { price, ...inputData } = req.body;
        const sanitizedData = { ...inputData };
        
        if ('validityYears' in sanitizedData) {
          const num = Number(sanitizedData.validityYears);
          sanitizedData.validityYears = !isNaN(num) ? Math.round(num) : null;
        }
        
        if ('maxPeople' in sanitizedData) {
          const num = Number(sanitizedData.maxPeople);
          sanitizedData.maxPeople = !isNaN(num) ? Math.round(num) : null;
        }
        
        if ('pricePerPerson' in sanitizedData) {
          const num = Number(sanitizedData.pricePerPerson);
          sanitizedData.pricePerPerson = !isNaN(num) ? num : null;
        }
        
        const course = await prisma.course.update({
          where: { id: req.params.id },
          data: sanitizedData
        });

        res.json(course);
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    app.delete('/courses/:id', async (req, res) => {
      await prisma.course.delete({ where: { id: req.params.id } });
      res.status(204).end();
    });

    // Bulk import dei corsi
    app.post('/courses/bulk-import', bodyParser.json({ limit: '50mb' }), bodyParser.urlencoded({ extended: true, limit: '50mb' }), async (req, res) => {
      try {
        if (!Array.isArray(req.body)) {
          return res.status(400).json({ error: 'Expected an array of courses' });
        }
        
        const courses = req.body;
        const results = { success: [], errors: [] };
        
        const sanitizeCourse = (course) => {
          const { id, price, ...data } = course;
          
          if (data.validityYears !== undefined) {
            const num = Number(data.validityYears);
            data.validityYears = !isNaN(num) ? Math.round(num) : null;
          }
          
          if (data.maxPeople !== undefined) {
            const num = Number(data.maxPeople);
            data.maxPeople = !isNaN(num) ? Math.round(num) : null;
          }
          
          if (data.pricePerPerson !== undefined) {
            const num = Number(data.pricePerPerson);
            data.pricePerPerson = !isNaN(num) ? num : null;
          }
          
          return data;
        };
        
        for (const course of courses) {
          try {
            const cleanedData = sanitizeCourse(course);
            let result;
            
            if (cleanedData.code) {
              result = await prisma.course.upsert({
                where: { code: cleanedData.code },
                update: cleanedData,
                create: cleanedData
              });
            } else {
              result = await prisma.course.create({ data: cleanedData });
            }
            
            results.success.push(result);
          } catch (err) {
            results.errors.push({ course, error: err.message });
          }
        }
        
        res.json(results);
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    // Endpoint per schedules con attestati
     app.get('/schedules-with-attestati', async (req, res) => {
       try {
         const schedules = await prisma.courseSchedule.findMany({
           include: {
             course: true,
             sessions: true,
             companies: { include: { company: true } },
             enrollments: { include: { employee: true } },
           },
           orderBy: { start_date: 'asc' },
         });
         
         const attestati = await prisma.attestato.findMany({});
         const attestatiBySchedule = new Set(attestati.map(a => a.scheduledCourseId));
         const result = schedules.map(s => ({
           ...s,
           hasAttestati: attestatiBySchedule.has(s.id)
         }));
         res.json(result);
       } catch (err) {
         res.status(500).json({ error: err.message });
       }
     });

     // Endpoint per ottenere lista template
     app.get('/templates', 
       authenticateToken(), 
       requirePermission('documents:read'), 
       async (req, res) => {
       try {
         const personId = req.person.id;
    const userCompanyId = req.person.companyId;
         
         // Get templates from database that belong to user's company
         const companyTemplates = await prisma.templateLink.findMany({
           where: {
             deletedAt: null,
             OR: [
               { companyId: req.person?.companyId },
               { isDefault: true },
               { companyId: null } // Global templates
             ]
           },
           select: {
             id: true,
             name: true,
             url: true,
             type: true,
             createdAt: true,
             updatedAt: true,
             fileFormat: true,
             isDefault: true
           },
           orderBy: {
             createdAt: 'desc'
           }
         });
         
         // Also get physical template files
         const templatesDir = path.join(process.cwd(), 'uploads', 'templates');
         let physicalTemplates = [];
         
         if (fs.existsSync(templatesDir)) {
           const files = fs.readdirSync(templatesDir);
           physicalTemplates = files.map(file => {
             const filePath = path.join(templatesDir, file);
             const stats = fs.statSync(filePath);
             return {
               name: file,
               size: stats.size,
               modified: stats.mtime,
               type: 'physical'
             };
           });
         }
         
         res.json({ 
           templates: companyTemplates,
           physicalTemplates,
           total: companyTemplates.length + physicalTemplates.length
         });
       } catch (error) {
         logger.error('Error listing templates', { service: 'proxy-server', error: error.message });
         res.status(500).json({ error: 'Internal server error' });
       }
     });

     // Endpoint per ottenere lista attestati
     app.get('/attestati', 
       authenticateToken(), 
       requirePermission('documents:read'), 
       async (req, res) => {
       try {
         const personId = req.person.id;
    const userCompanyId = req.person.companyId;
         
         // Get attestati from database that belong to user's company
         const companyAttestati = await prisma.attestato.findMany({
           where: {
             deletedAt: null,
             partecipante: {
               companyId: userCompanyId
             }
           },
           include: {
             partecipante: {
               select: {
                 id: true,
                 first_name: true,
                 last_name: true,
                 email: true
               }
             },
             scheduledCourse: {
               select: {
                 id: true,
                 course: {
                   select: {
                     name: true,
                     code: true
                   }
                 }
               }
             }
           },
           orderBy: {
             dataGenerazione: 'desc'
           }
         });
         
         // Also check physical files and match with database records
         const attestatiDir = path.join(process.cwd(), 'uploads', 'attestati');
         let physicalFiles = [];
         
         if (fs.existsSync(attestatiDir)) {
           const files = fs.readdirSync(attestatiDir);
           physicalFiles = files.filter(file => {
             // Check if this file belongs to user's company by matching with database
             return companyAttestati.some(attestato => attestato.nomeFile === file);
           }).map(file => {
             const filePath = path.join(attestatiDir, file);
             const stats = fs.statSync(filePath);
             const dbRecord = companyAttestati.find(attestato => attestato.nomeFile === file);
             return {
               name: file,
               size: stats.size,
               modified: stats.mtime,
               participant: dbRecord?.partecipante,
               course: dbRecord?.scheduledCourse?.course
             };
           });
         }
         
         res.json({ 
           attestati: companyAttestati,
           physicalFiles,
           total: companyAttestati.length
         });
       } catch (error) {
         logger.error('Error listing attestati', { service: 'proxy-server', error: error.message });
         res.status(500).json({ error: 'Internal server error' });
       }
     });

    // Proxy middleware for trainers (direct to API server)
    app.use('/trainers', createProxyMiddleware({
      target: apiServerTarget,
      changeOrigin: true,
      timeout: 30000,
      proxyTimeout: 30000,
      onError: (err, req, res) => {
        logger.error('Proxy error for trainers', { service: 'proxy-server', error: err.message, path: req.path });
        res.status(502).json({ error: 'Proxy error', message: err.message });
      },
      onProxyReq: (proxyReq, req, res) => {
        logger.debug('Proxying trainers request', { service: 'proxy-server', method: req.method, path: req.path });
      }
    }));

    // Proxy middleware for employees (direct to API server)
    app.use('/employees', createProxyMiddleware({
      target: apiServerTarget,
      changeOrigin: true,
      timeout: 30000,
      proxyTimeout: 30000,
      onError: (err, req, res) => {
        logger.error('Proxy error for employees', { service: 'proxy-server', error: err.message, path: req.path });
        res.status(502).json({ error: 'Proxy error', message: err.message });
      },
      onProxyReq: (proxyReq, req, res) => {
        logger.debug('Proxying employees request', { service: 'proxy-server', method: req.method, path: req.path });
      }
    }));

    // CRITICAL: Auth middleware MUST be defined BEFORE the generic /api middleware
    // Handle /v1/auth routes (from Vite proxy rewrite) - FIRST
    console.log('🔧 Setting up /v1/auth middleware');
    app.use('/v1/auth', (req, res, next) => {
      console.log('🚨 [V1 AUTH MIDDLEWARE] HIT! Method:', req.method, 'OriginalUrl:', req.originalUrl, 'Path:', req.path);
      console.log('🚨 [V1 AUTH MIDDLEWARE] Headers:', req.headers);
      next();
    }, apiLimiter, createProxyMiddleware({
      target: apiServerTarget,
      changeOrigin: true,
      timeout: 30000,
      proxyTimeout: 30000,
      pathRewrite: {
        '^/v1/auth': '/api/v1/auth' // Add /api prefix back
      },
      onError: (err, req, res) => {
        logger.error('Proxy error for V1 auth', { service: 'proxy-server', error: err.message, path: req.path });
        if (!res.headersSent) {
          res.status(502).json({ error: 'Proxy error', message: err.message });
        }
      },
      onProxyReq: (proxyReq, req, res) => {
        console.log('🔍 DEBUG: Proxying v1 auth request to:', proxyReq.path);
        logger.info('Proxying v1 auth request', { 
          service: 'proxy-server', 
          method: req.method, 
          originalPath: req.path,
          originalUrl: req.url,
          targetPath: proxyReq.path
        });
      }
    }));

    // Removed duplicate /api/v1/auth middleware - handled later with OPTIONS support

    // Handle /api/auth routes specifically (MUST be SECOND before any other /api middleware)
    console.log('🔧 Setting up /api/auth middleware');
    
    // OPTIONS handlers moved to top of initializeServer function
    
    app.use('/api/auth', (req, res, next) => {
      console.log('🚨🚨🚨 [AUTH MIDDLEWARE] HIT! Method:', req.method, 'OriginalUrl:', req.originalUrl, 'Path:', req.path);
      console.log('🚨🚨🚨 [AUTH MIDDLEWARE] Headers:', req.headers);
      console.log('🚨🚨🚨 [AUTH MIDDLEWARE] Query:', req.query);
      
      // Skip OPTIONS requests - they are handled by specific OPTIONS handlers above
      if (req.method === 'OPTIONS') {
        console.log('🚨 [AUTH MIDDLEWARE] Skipping OPTIONS request - handled by specific handlers');
        return next('route'); // Skip this middleware and continue to next route
      }
      
      // Set CORS headers for non-OPTIONS requests
      res.header('Access-Control-Allow-Origin', 'http://localhost:5173');
      res.header('Access-Control-Allow-Credentials', 'true');
      
      next();
    }, apiLimiter, createProxyMiddleware({
      target: apiServerTarget,
      changeOrigin: true,
      timeout: 30000,
      proxyTimeout: 30000,
      // CRITICAL FIX: Reconstruct the full /api/auth path
      pathRewrite: {
        '^/login': '/api/auth/login',
        '^/verify': '/api/auth/verify',
        '^/logout': '/api/auth/logout',
        '^/refresh': '/api/auth/refresh'
      },
      onError: (err, req, res) => {
        logger.error('Proxy error for API auth', { service: 'proxy-server', error: err.message, path: req.path });
        if (!res.headersSent) {
          res.status(502).json({ error: 'Proxy error', message: err.message });
        }
      },
      onProxyReq: (proxyReq, req, res) => {
        logger.info('Proxying auth request', { 
          service: 'proxy-server', 
          method: req.method, 
          originalPath: req.path,
          targetPath: proxyReq.path
        });
      }
    }));

    // Legacy auth routes (redirect to /api/auth)
    app.use('/auth', createProxyMiddleware({
      target: 'http://127.0.0.1:4001',
      changeOrigin: true,
      pathRewrite: {
        '^/auth': '/api/auth', // Redirect auth requests to API server
      },
      onError: (err, req, res) => {
        logger.error('Proxy error for legacy auth', { service: 'proxy-server', error: err.message, path: req.path, url: req.url });
        if (!res.headersSent) {
          res.status(502).json({ error: 'Proxy error', message: err.message });
        }
      }
    }));

    // V1 auth middleware already defined above - removing duplicate

    // Proxy middleware for specific API routes (excluding auth which is handled above)
    // Handle /api/companies routes (redirect to /api/v1/companies)
    console.log('🔧 Setting up /api/companies middleware');
    app.use('/api/companies', (req, res, next) => {
      console.log('🔍 DEBUG: /api/companies middleware hit:', req.method, req.originalUrl, req.path);
      next();
    }, apiLimiter, createProxyMiddleware({
      target: apiServerTarget,
      changeOrigin: true,
      timeout: 30000,
      proxyTimeout: 30000,
      pathRewrite: {
        '^/api/companies': '/api/v1/companies', // Redirect to v1 endpoint
      },
      onError: (err, req, res) => {
        logger.error('Proxy error for API companies', { service: 'proxy-server', error: err.message, path: req.path });
        if (!res.headersSent) {
          res.status(502).json({ error: 'Proxy error', message: err.message });
        }
      },
      onProxyReq: (proxyReq, req, res) => {
        console.log('🔍 DEBUG: Proxying companies request to:', proxyReq.path);
        logger.info('Proxying companies request', { 
          service: 'proxy-server', 
          method: req.method, 
          originalPath: req.path,
          originalUrl: req.url,
          targetPath: proxyReq.path
        });
      }
    }));

    // Handle /v1/companies routes (from Vite proxy rewrite)
    console.log('🔧 Setting up /v1/companies middleware');
    app.use('/v1/companies', (req, res, next) => {
      console.log('🚨 [V1 COMPANIES MIDDLEWARE] HIT! Method:', req.method, 'OriginalUrl:', req.originalUrl, 'Path:', req.path);
      console.log('🚨 [V1 COMPANIES MIDDLEWARE] Headers:', req.headers);
      next();
    }, apiLimiter, createProxyMiddleware({
      target: apiServerTarget,
      changeOrigin: true,
      timeout: 30000,
      proxyTimeout: 30000,
      pathRewrite: {
        '^/v1/companies': '/api/v1/companies', // Add /api prefix back
      },
      onError: (err, req, res) => {
        logger.error('Proxy error for V1 companies', { service: 'proxy-server', error: err.message, path: req.path });
        if (!res.headersSent) {
          res.status(502).json({ error: 'Proxy error', message: err.message });
        }
      },
      onProxyReq: (proxyReq, req, res) => {
        console.log('🔍 DEBUG: Proxying v1 companies request to:', proxyReq.path);
        logger.info('Proxying v1 companies request', { 
          service: 'proxy-server', 
          method: req.method, 
          originalPath: req.path,
          originalUrl: req.url,
          targetPath: proxyReq.path
        });
      }
    }));

    // Handle /api/v1/companies routes
    console.log('🔧 Setting up /api/v1/companies middleware');
    app.use('/api/v1/companies', (req, res, next) => {
      console.log('🔍 DEBUG: /api/v1/companies middleware hit:', req.method, req.originalUrl, req.path);
      next();
    }, apiLimiter, createProxyMiddleware({
      target: apiServerTarget,
      changeOrigin: true,
      timeout: 30000,
      proxyTimeout: 30000,
      pathRewrite: {
        '^/': '/api/v1/companies', // CRITICAL FIX: Express removes /api/v1/companies prefix, so we need to add it back
      },
      onError: (err, req, res) => {
        logger.error('Proxy error for API v1 companies', { service: 'proxy-server', error: err.message, path: req.path });
        if (!res.headersSent) {
          res.status(502).json({ error: 'Proxy error', message: err.message });
        }
      },
      onProxyReq: (proxyReq, req, res) => {
        console.log('🔍 DEBUG: Proxying v1 companies request to:', proxyReq.path);
        logger.info('Proxying v1 companies request', { 
          service: 'proxy-server', 
          method: req.method, 
          originalPath: req.path,
          originalUrl: req.url,
          targetPath: proxyReq.path
        });
      }
    }));

    // Handle /api/tenant routes
    app.use('/api/tenant', apiLimiter, createProxyMiddleware({
      target: apiServerTarget,
      changeOrigin: true,
      timeout: 30000,
      proxyTimeout: 30000,
      pathRewrite: {
        '^/': '/api/tenants', // CRITICAL FIX: Express removes /api/tenant prefix, map to correct /api/tenants endpoint
      },
      onError: (err, req, res) => {
        logger.error('Proxy error for API tenant', { service: 'proxy-server', error: err.message, path: req.path });
        if (!res.headersSent) {
          res.status(502).json({ error: 'Proxy error', message: err.message });
        }
      }
    }));

    // Handle /api/roles routes specifically (MUST be before /roles middleware and generic /api middleware)
    console.log('🔧 Setting up /api/roles middleware');
    app.use('/api/roles', (req, res, next) => {
      console.log('🚨🚨🚨 [ROLES MIDDLEWARE] HIT! Method:', req.method, 'OriginalUrl:', req.originalUrl, 'Path:', req.path);
      console.log('🚨🚨🚨 [ROLES MIDDLEWARE] Headers:', req.headers);
      console.log('🚨🚨🚨 [ROLES MIDDLEWARE] URL:', req.url);
      
      // Skip proxy for OPTIONS requests - let local OPTIONS handlers manage them
      if (req.method === 'OPTIONS') {
        console.log('🚨🚨🚨 [ROLES MIDDLEWARE] Skipping proxy for OPTIONS request');
        return next('route'); // Skip this middleware and continue to next route
      }
      
      next();
    }, 
    // Skip rate limiting for /api/roles completely (critical endpoint)
    (req, res, next) => {
      console.log('🚨 [API ROLES] Skipping rate limiting for critical endpoint');
      return next();
    }, 
    createProxyMiddleware({
      target: apiServerTarget,
      changeOrigin: true,
      timeout: 30000,
      proxyTimeout: 30000,
      pathRewrite: {
        '^/': '/api/roles', // CRITICAL FIX: Express removes /api/roles prefix, so we need to add it back
      },
      onError: (err, req, res) => {
        console.log('🚨🚨🚨 [ROLES PROXY ERROR]:', err.message, 'Path:', req.path);
        logger.error('Proxy error for API roles', { service: 'proxy-server', error: err.message, path: req.path });
        if (!res.headersSent) {
          res.status(502).json({ error: 'Proxy error', message: err.message });
        }
      },
      onProxyReq: (proxyReq, req, res) => {
        console.log('🚨🚨🚨 [ROLES PROXY] Proxying request:');
        console.log('🚨🚨🚨 [ROLES PROXY] - Original req.path:', req.path);
        console.log('🚨🚨🚨 [ROLES PROXY] - Original req.url:', req.url);
        console.log('🚨🚨🚨 [ROLES PROXY] - Original req.originalUrl:', req.originalUrl);
        console.log('🚨🚨🚨 [ROLES PROXY] - Target proxyReq.path:', proxyReq.path);
        console.log('🚨🚨🚨 [ROLES PROXY] - Full target URL:', `${apiServerTarget}${proxyReq.path}`);
        logger.info('Proxying roles request', { 
          service: 'proxy-server', 
          method: req.method, 
          originalPath: req.path,
          originalUrl: req.url,
          targetPath: proxyReq.path
        });
      },
      onProxyRes: (proxyRes, req, res) => {
        console.log('🚨🚨🚨 [ROLES PROXY RESPONSE] Status:', proxyRes.statusCode);
        console.log('🚨🚨🚨 [ROLES PROXY RESPONSE] Headers:', proxyRes.headers);
      }
    }));

    // Handle /roles routes (from Vite proxy rewrite)
    console.log('🔧 Setting up /roles middleware');
    app.use('/roles', (req, res, next) => {
      console.log('🚨 [V1 ROLES MIDDLEWARE] HIT! Method:', req.method, 'OriginalUrl:', req.originalUrl, 'Path:', req.path);
      console.log('🚨 [V1 ROLES MIDDLEWARE] Headers:', req.headers);
      
      // Skip proxy for OPTIONS requests - let local OPTIONS handlers manage them
      if (req.method === 'OPTIONS') {
        console.log('🚨 [V1 ROLES MIDDLEWARE] Skipping proxy for OPTIONS request');
        return next('route'); // Skip this middleware and continue to next route
      }
      
      next();
    }, 
    // Skip rate limiting for /roles completely (critical endpoint)
    (req, res, next) => {
      console.log('🚨 [V1 ROLES] Skipping rate limiting for critical endpoint');
      return next();
    }, 
    createProxyMiddleware({
      target: apiServerTarget,
      changeOrigin: true,
      timeout: 30000,
      proxyTimeout: 30000,
      pathRewrite: {
        '^/roles': '/api/roles', // Add /api prefix back
      },
      onError: (err, req, res) => {
        logger.error('Proxy error for V1 roles', { service: 'proxy-server', error: err.message, path: req.path });
        if (!res.headersSent) {
          res.status(502).json({ error: 'Proxy error', message: err.message });
        }
      },
      onProxyReq: (proxyReq, req, res) => {
        console.log('🔍 DEBUG: Proxying v1 roles request to:', proxyReq.path);
        logger.info('Proxying v1 roles request', { 
          service: 'proxy-server', 
          method: req.method, 
          originalPath: req.path,
          originalUrl: req.url,
          targetPath: proxyReq.path
        });
      }
    }));

    // Handle /api/persons routes specifically (MUST be before generic /api middleware)
    console.log('🔧 Setting up /api/persons middleware');
    app.use('/api/persons', (req, res, next) => {
      console.log('🚨 [API PERSONS MIDDLEWARE] HIT! Method:', req.method, 'OriginalUrl:', req.originalUrl, 'Path:', req.path);
      console.log('🚨 [API PERSONS MIDDLEWARE] Headers:', req.headers);
      next();
    }, 
    // Skip rate limiting for /api/persons completely (critical endpoint)
    (req, res, next) => {
      console.log('🚨 [API PERSONS] Skipping rate limiting for critical endpoint');
      return next();
    }, 
    createProxyMiddleware({
      target: apiServerTarget,
      changeOrigin: true,
      timeout: 30000,
      proxyTimeout: 30000,
      pathRewrite: {
        '^/': '/api/persons', // CRITICAL FIX: Express removes /api/persons prefix, so we need to add it back
      },
      onError: (err, req, res) => {
        logger.error('Proxy error for API persons', { service: 'proxy-server', error: err.message, path: req.path });
        if (!res.headersSent) {
          res.status(502).json({ error: 'Proxy error', message: err.message });
        }
      },
      onProxyReq: (proxyReq, req, res) => {
        console.log('🔍 DEBUG: Proxying persons request to:', proxyReq.path);
        logger.info('Proxying persons request', { 
          service: 'proxy-server', 
          method: req.method, 
          originalPath: req.path,
          originalUrl: req.url,
          targetPath: proxyReq.path
        });
      }
    }));

    // Handle /persons routes (from Vite proxy rewrite)
    console.log('🔧 Setting up /persons middleware');
    app.use('/persons', (req, res, next) => {
      console.log('🚨 [V1 PERSONS MIDDLEWARE] HIT! Method:', req.method, 'OriginalUrl:', req.originalUrl, 'Path:', req.path);
      console.log('🚨 [V1 PERSONS MIDDLEWARE] Headers:', req.headers);
      next();
    }, 
    // Skip rate limiting for /persons completely (critical endpoint)
    (req, res, next) => {
      console.log('🚨 [V1 PERSONS] Skipping rate limiting for critical endpoint');
      return next();
    }, 
    createProxyMiddleware({
      target: apiServerTarget,
      changeOrigin: true,
      timeout: 30000,
      proxyTimeout: 30000,
      pathRewrite: {
        '^/persons': '/api/persons', // Add /api prefix back
      },
      onError: (err, req, res) => {
        logger.error('Proxy error for V1 persons', { service: 'proxy-server', error: err.message, path: req.path });
        if (!res.headersSent) {
          res.status(502).json({ error: 'Proxy error', message: err.message });
        }
      },
      onProxyReq: (proxyReq, req, res) => {
        console.log('🔍 DEBUG: Proxying v1 persons request to:', proxyReq.path);
        logger.info('Proxying v1 persons request', { 
          service: 'proxy-server', 
          method: req.method, 
          originalPath: req.path,
          originalUrl: req.url,
          targetPath: proxyReq.path
        });
      }
    }));

    // Handle /api/users routes (for user preferences and profile)
    console.log('🔧 Setting up /api/users middleware');
    app.use('/api/users', (req, res, next) => {
      console.log('🔍 DEBUG: /api/users middleware hit:', req.method, req.originalUrl, req.path);
      next();
    }, 
    // Skip rate limiting for /api/users completely (critical endpoint)
    (req, res, next) => {
      console.log('🚨 [API USERS] Skipping rate limiting for critical endpoint');
      return next();
    }, 
    createProxyMiddleware({
      target: apiServerTarget,
      changeOrigin: true,
      timeout: 30000,
      proxyTimeout: 30000,
      pathRewrite: {
        '^/': '/api/users', // CRITICAL FIX: Express removes /api/users prefix, so we need to add it back
      },
      onError: (err, req, res) => {
        logger.error('Proxy error for API users', { service: 'proxy-server', error: err.message, path: req.path });
        if (!res.headersSent) {
          res.status(502).json({ error: 'Proxy error', message: err.message });
        }
      },
      onProxyReq: (proxyReq, req, res) => {
        console.log('🔍 DEBUG: Proxying users request to:', proxyReq.path);
        logger.info('Proxying users request', { 
          service: 'proxy-server', 
          method: req.method, 
          originalPath: req.path,
          originalUrl: req.url,
          targetPath: proxyReq.path
        });
      }
    }));

    // Handle /api/tenants routes specifically (MUST be before generic /api middleware)
    console.log('🔧 Setting up /api/tenants middleware');
    app.use('/api/tenants', (req, res, next) => {
      console.log('🚨 [API TENANTS MIDDLEWARE] HIT! Method:', req.method, 'OriginalUrl:', req.originalUrl, 'Path:', req.path);
      console.log('🚨 [API TENANTS MIDDLEWARE] Headers:', req.headers);
      
      // Skip proxy for OPTIONS requests - let local OPTIONS handlers manage them
      if (req.method === 'OPTIONS') {
        console.log('🚨 [API TENANTS MIDDLEWARE] Skipping proxy for OPTIONS request');
        return next('route'); // Skip this middleware and continue to next route
      }
      
      next();
    }, 
    // Skip rate limiting for /api/tenants completely (critical endpoint)
    (req, res, next) => {
      console.log('🚨 [API TENANTS] Skipping rate limiting for critical endpoint');
      return next();
    }, 
    createProxyMiddleware({
      target: apiServerTarget,
      changeOrigin: true,
      timeout: 30000,
      proxyTimeout: 30000,
      pathRewrite: {
        '^/': '/api/tenants', // CRITICAL FIX: Express removes /api/tenants prefix, so we need to add it back
      },
      onError: (err, req, res) => {
        logger.error('Proxy error for API tenants', { service: 'proxy-server', error: err.message, path: req.path });
        if (!res.headersSent) {
          res.status(502).json({ error: 'Proxy error', message: err.message });
        }
      },
      onProxyReq: (proxyReq, req, res) => {
        console.log('🔍 DEBUG: Proxying tenants request to:', proxyReq.path);
        logger.info('Proxying tenants request', { 
          service: 'proxy-server', 
          method: req.method, 
          originalPath: req.path,
          originalUrl: req.url,
          targetPath: proxyReq.path
        });
      }
    }));

    // Handle /api/v1/auth routes specifically (MUST be before generic /api middleware)
    console.log('🔧 Setting up /api/v1/auth middleware');
    app.use('/api/v1/auth', (req, res, next) => {
      console.log('🚨 [API V1 AUTH MIDDLEWARE] HIT! Method:', req.method, 'OriginalUrl:', req.originalUrl, 'Path:', req.path);
      console.log('🚨 [API V1 AUTH MIDDLEWARE] Headers:', req.headers);
      
      // Skip proxy for OPTIONS requests - let local OPTIONS handlers manage them
      if (req.method === 'OPTIONS') {
        console.log('🚨 [API V1 AUTH MIDDLEWARE] Skipping proxy for OPTIONS request');
        return next();
      }
      
      next();
    }, apiLimiter, createProxyMiddleware({
      target: apiServerTarget,
      changeOrigin: true,
      timeout: 30000,
      proxyTimeout: 30000,
      pathRewrite: {
        '^/': '/api/v1/auth', // CRITICAL FIX: Express removes /api/v1/auth prefix, so we need to add it back
      },
      onError: (err, req, res) => {
        logger.error('Proxy error for API v1 auth', { service: 'proxy-server', error: err.message, path: req.path });
        if (!res.headersSent) {
          res.status(502).json({ error: 'Proxy error', message: err.message });
        }
      },
      onProxyReq: (proxyReq, req, res) => {
        console.log('🔍 DEBUG: Proxying v1 auth request to:', proxyReq.path);
        logger.info('Proxying v1 auth request', { 
          service: 'proxy-server', 
          method: req.method, 
          originalPath: req.path,
          originalUrl: req.url,
          targetPath: proxyReq.path
        });
      }
    }));

    // REMOVED: Generic /api middleware that was interfering with specific middleware
    // All /api routes are now handled by specific middleware above
    console.log('🔧 Generic /api middleware REMOVED - using only specific middleware');

    // Handle test endpoints that don't start with /api
    console.log('🔧 Setting up /test-outside-api middleware');
    app.use('/test-outside-api', (req, res, next) => {
      console.log('🚨 [TEST-OUTSIDE-API MIDDLEWARE] HIT! Method:', req.method, 'OriginalUrl:', req.originalUrl, 'Path:', req.path);
      next();
    }, createProxyMiddleware({
      target: apiServerTarget,
      changeOrigin: true,
      timeout: 30000,
      proxyTimeout: 30000,
      // No pathRewrite needed - keep the original path
      onError: (err, req, res) => {
        logger.error('Proxy error for test-outside-api', { service: 'proxy-server', error: err.message, path: req.path });
        if (!res.headersSent) {
          res.status(502).json({ error: 'Proxy error', message: err.message });
        }
      },
      onProxyReq: (proxyReq, req, res) => {
        console.log('🔍 DEBUG: Proxying test-outside-api request to:', proxyReq.path);
        logger.info('Proxying test-outside-api request', { 
          service: 'proxy-server', 
          method: req.method, 
          originalPath: req.path,
          originalUrl: req.url,
          targetPath: proxyReq.path
        });
      }
    }));

    // Handle /test endpoint
    console.log('🔧 Setting up /test middleware');
    app.use('/test', (req, res, next) => {
      console.log('🚨 [TEST MIDDLEWARE] HIT! Method:', req.method, 'OriginalUrl:', req.originalUrl, 'Path:', req.path);
      next();
    }, createProxyMiddleware({
      target: apiServerTarget,
      changeOrigin: true,
      timeout: 30000,
      proxyTimeout: 30000,
      // No pathRewrite needed - keep the original path
      onError: (err, req, res) => {
        logger.error('Proxy error for test', { service: 'proxy-server', error: err.message, path: req.path });
        if (!res.headersSent) {
          res.status(502).json({ error: 'Proxy error', message: err.message });
        }
      },
      onProxyReq: (proxyReq, req, res) => {
        console.log('🔍 DEBUG: Proxying test request to:', proxyReq.path);
        logger.info('Proxying test request', { 
          service: 'proxy-server', 
          method: req.method, 
          originalPath: req.path,
          originalUrl: req.url,
          targetPath: proxyReq.path
        });
      }
    }));

    // Handle /health endpoint
    console.log('🔧 Setting up /health middleware');
    app.use('/health', (req, res, next) => {
      console.log('🚨 [HEALTH MIDDLEWARE] HIT! Method:', req.method, 'OriginalUrl:', req.originalUrl, 'Path:', req.path);
      next();
    }, createProxyMiddleware({
      target: apiServerTarget,
      changeOrigin: true,
      timeout: 30000,
      proxyTimeout: 30000,
      // No pathRewrite needed - keep the original path
      onError: (err, req, res) => {
        logger.error('Proxy error for health', { service: 'proxy-server', error: err.message, path: req.path });
        if (!res.headersSent) {
          res.status(502).json({ error: 'Proxy error', message: err.message });
        }
      },
      onProxyReq: (proxyReq, req, res) => {
        console.log('🔍 DEBUG: Proxying health request to:', proxyReq.path);
        logger.info('Proxying health request', { 
          service: 'proxy-server', 
          method: req.method, 
          originalPath: req.path,
          originalUrl: req.url,
          targetPath: proxyReq.path
        });
      }
    }));

    // Proxy middleware for Documents routes
    app.use('/generate', createProxyMiddleware({
      target: documentsServerTarget,
      changeOrigin: true,
      timeout: 60000,
      proxyTimeout: 60000,
      onError: (err, req, res) => {
        logger.error('Proxy error for Documents', { service: 'proxy-server', error: err.message, path: req.path });
        res.status(502).json({ error: 'Proxy error', message: err.message });
      },
      onProxyReq: (proxyReq, req, res) => {
        logger.debug('Proxying Documents request', { service: 'proxy-server', method: req.method, path: req.path });
      }
    }));

    // Test endpoint to verify proxy server has loaded recent changes
    app.get('/proxy-test-updated', (req, res) => {
      console.log('🚨 [PROXY-TEST-UPDATED] Endpoint hit - proxy server has loaded recent changes!');
      res.json({
        message: 'Proxy server has loaded recent changes',
        timestamp: new Date().toISOString(),
        version: '2025-07-12-updated-v2',
        middlewareStatus: {
          rolesMiddleware: 'loaded with enhanced debugging',
          tenantsMiddleware: 'loaded',
          genericApiMiddleware: 'loaded with skip logic'
        }
      });
    });

    // Test endpoint specifically for roles middleware debugging
    app.get('/test-roles-middleware', (req, res) => {
      console.log('🚨 [TEST-ROLES-MIDDLEWARE] Direct test endpoint hit!');
      res.json({
        message: 'Roles middleware test endpoint',
        timestamp: new Date().toISOString(),
        note: 'If you see this, the proxy server has loaded the latest changes'
      });
    });

    // Error handling middleware (must be last)
    app.use(notFoundHandler);
    app.use(globalErrorHandler);

    // Avvio del server proxy
    const server = app.listen(PORT, '0.0.0.0', () => {
      logger.info('Proxy Server started successfully', { service: 'proxy-server', port: PORT, host: '0.0.0.0', timestamp: new Date().toISOString() });
    });

    // Graceful shutdown - Configurazione per development/production
    if (process.env.NODE_ENV === 'production') {
      process.on('SIGTERM', () => {
        logger.info('SIGTERM received, shutting down gracefully', { service: 'proxy-server' });
        server.close(() => {
          try {
            loadBalancer.stopHealthChecks();
            shutdownAuth();
            logger.info('Proxy Server shutdown complete', { service: 'proxy-server' });
            process.exit(0);
          } catch (error) {
            logger.error('Error during shutdown', { service: 'proxy-server', error: error.message, stack: error.stack });
            process.exit(1);
          }
        });
      });

      process.on('SIGINT', () => {
        logger.info('SIGINT received, shutting down gracefully', { service: 'proxy-server' });
        server.close(() => {
          try {
            loadBalancer.stopHealthChecks();
            shutdownAuth();
            logger.info('Proxy Server shutdown complete', { service: 'proxy-server' });
            process.exit(0);
          } catch (error) {
            logger.error('Error during shutdown', { service: 'proxy-server', error: error.message, stack: error.stack });
            process.exit(1);
          }
        });
      });
    } else {
      // Development mode: Ignora completamente i segnali SIGINT/SIGTERM
      process.on('SIGTERM', () => {
        logger.info('🔧 SIGTERM ignored in development mode', { service: 'proxy-server' });
      });
      
      process.on('SIGINT', () => {
        logger.info('🔧 SIGINT ignored in development mode', { service: 'proxy-server' });
      });
      
      logger.info('🔧 Development mode: SIGINT/SIGTERM signals will be ignored to prevent automatic shutdowns', { service: 'proxy-server' });
    }

  } catch (error) {
    logger.error('Failed to initialize authentication system', { service: 'proxy-server', error: error.message, stack: error.stack });
    process.exit(1);
  }
}

// Initialize and start the server
initializeServer().catch((error) => {
  logger.error('Failed to initialize server', { service: 'proxy-server', error: error.message, stack: error.stack });
  process.exit(1);
});