import express from 'express';
import bodyParser from 'body-parser';
import cors from 'cors';
import { PrismaClient } from '@prisma/client';
import multer from 'multer';
import path from 'path';
import { google } from 'googleapis';
import fs from 'fs';
import { mkdirp } from 'mkdirp';
import { fileURLToPath } from 'url';
import dotenv from 'dotenv';
import axios from 'axios';
import googleApiService from './utils/googleApiService.js';
import prisma from './config/prisma-optimization.js';
import { RedisService } from './config/redis-config.js';
import { 
  requestPerformanceMiddleware, 
  databasePerformanceMiddleware,
  getPerformanceDashboard,
  startPerformanceMonitoring
} from './middleware/performance-monitor.js';

// Import authentication
import { createAuthRouter, initializeAuth, shutdownAuth } from './auth/index.js';
import middleware from './auth/middleware.js';

// Import route modules
import coursesRoutes from './routes/courses-routes.js';
import usersRoutes from './routes/users-routes.js';
import companiesRoutes from './routes/companies-routes.js';
import personRoutes from './routes/person-routes.js';
import employeesRoutes from './routes/employees-routes.js';
import schedulesRoutes from './routes/schedules-routes.js';
import gdprRoutes from './routes/gdpr.js';
import rolesRoutes from './routes/roles.js';
import settingsRoutes from './routes/settings-routes.js';
import advancedPermissionsRoutes from './routes/advanced-permissions.js';
import tenantsRoutes from './routes/tenants.js';
import { employeesRouter, trainersRouter, virtualEntitiesRouter } from './routes/virtualEntityRoutes.js';
import dashboardRoutes from './routes/dashboard-routes.js';

// Import advanced form system routes
import formTemplatesRoutes from './routes/form-templates-routes.js';
import advancedSubmissionsRoutes from './routes/advanced-submissions-routes.js';

// Import v1 routes
import authV1Routes from './routes/v1/auth.js';
import permissionsV1Routes from './routes/v1/permissions.js';

// Import logging and error handling
import { logger, httpLogger } from './utils/logger.js';
import { globalErrorHandler, notFoundHandler } from './middleware/errorHandler.js';

// Import tenant middleware
import { tenantMiddleware } from './middleware/tenant.js';

const { authenticate: authenticateToken, authorize: requirePermission, requireSameCompany: requireCompanyAccess } = middleware;

dotenv.config({ path: '../.env' });

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Prisma Client is already initialized in the imported module

// Add performance monitoring middleware to Prisma - TEMPORARILY DISABLED FOR TIMEOUT DEBUG
// prisma.$use(databasePerformanceMiddleware.query);

// Initialize Redis Service
const redisService = new RedisService();

// Aggiungiamo middleware per conversione automatica dei tipi numerici
prisma.$use(async (params, next) => {
  // Solo per operazioni Course
  if (params.model === 'Course') {
    // Converti i tipi nelle operazioni di creazione e aggiornamento
    if (params.action === 'create' || params.action === 'update' || params.action === 'upsert') {
      const data = params.args.data;
      
      if (data) {
        try {
          // Funzione helper per convertire campi numerici
          const convertNumericField = (value, isInteger = false) => {
            if (value === null || value === '' || value === undefined) return null;
            const num = Number(value);
            if (isNaN(num)) return null;
            return isInteger ? Math.round(num) : num;
          };
          
          // Converti i campi numerici
          if ('validityYears' in data) {
            data.validityYears = convertNumericField(data.validityYears, true);
          }
          
          if ('maxPeople' in data) {
            data.maxPeople = convertNumericField(data.maxPeople, true);
          }
          
          if ('pricePerPerson' in data) {
            data.pricePerPerson = convertNumericField(data.pricePerPerson, false);
          }
        } catch (e) {
          // Ignora gli errori e continua
        }
      }
    }
  }
  
  // Continua con l'operazione normale
  return next(params);
});

const app = express();

const PORT = 4001;

// Authentication system is initialized through route mounting
logger.info('Authentication system ready in API Server', { service: 'api-server', port: PORT });

// Configurazione CORS
app.use(cors({
  origin: [
    'http://localhost:5173',
    'http://localhost:3000',
    'http://localhost:5173'
  ],
  methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
  optionsSuccessStatus: 204,
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true
}));

// HTTP request logging
app.use(httpLogger);

// Performance monitoring middleware - TEMPORARILY DISABLED
// app.use(requestPerformanceMiddleware);

// Test endpoint fuori da /api - PRIMA DI TUTTO
app.get('/test-outside-api', (req, res) => {
  console.log('ðŸ” Test endpoint /test-outside-api chiamato');
  res.json({
    success: true,
    message: 'Outside API endpoint working',
    timestamp: new Date().toISOString()
  });
});

// Test endpoint senza autenticazione - DEVE essere prima di TUTTI i middleware
app.get('/api/test-direct', (req, res) => {
  console.log('ðŸ” Test endpoint /api/test-direct chiamato');
  res.json({
    success: true,
    message: 'Direct endpoint working',
    timestamp: new Date().toISOString()
  });
});

// Configurazione bodyParser
app.use(bodyParser.json({ limit: '50mb' }));
app.use(bodyParser.urlencoded({ extended: true, limit: '50mb' }));

// Tenant middleware - must be before routes that need tenant context
app.use('/api', tenantMiddleware);

// Mount v1 routes FIRST (more specific paths)
app.use('/api/v1/auth', authV1Routes);
app.use('/api/v1', permissionsV1Routes);

// Mount auth routes for backward compatibility
app.use('/api/auth', authV1Routes);

// Mount authentication routes AFTER (more generic paths) - using different path to avoid conflicts
const authRoutes = createAuthRouter();
app.use('/api/legacy', authRoutes);

// Mount auth routes on /api for user management endpoints - COMMENTED OUT TO AVOID CONFLICTS WITH V1 ROUTES
// app.use('/api', authRoutes);

// Mount route modules
app.use('/api/dashboard', dashboardRoutes); // Dashboard optimized routes
app.use('/api/persons', personRoutes); // New unified Person routes
app.use('/api/gdpr', gdprRoutes); // GDPR compliance routes
app.use('/api/roles', rolesRoutes); // Role and permission management routes
app.use('/api/advanced-permissions', advancedPermissionsRoutes); // Advanced permissions management routes
app.use('/api/settings', settingsRoutes); // Settings management routes
app.use('/api/tenants', tenantsRoutes); // Tenant management routes
app.use('/api/employees', employeesRouter); // Virtual entity routes for employees
app.use('/api/trainers', trainersRouter); // Virtual entity routes for trainers
app.use('/api/virtual-entities', virtualEntitiesRouter); // Virtual entity management routes

// Advanced form system routes
app.use('/api/v1/form-templates', formTemplatesRoutes); // Form templates management
app.use('/api/v1/submissions/advanced', advancedSubmissionsRoutes); // Advanced submissions management

app.use('/courses', coursesRoutes);
app.use('/api/user', usersRoutes); // User preferences and profile routes
app.use('/api/users', usersRoutes); // Frontend expects /api/users/preferences
app.use('/users', usersRoutes); // Backward compatibility
app.use('/api/v1/companies', companiesRoutes); // Updated to match frontend expectations
app.use('/api/companies', companiesRoutes); // Frontend expects /api/companies
app.use('/employees', employeesRoutes); // Backward compatible
app.use('/schedules', schedulesRoutes);

// Configurazione multer per upload file
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    const uploadPath = path.join(__dirname, 'uploads');
    mkdirp.sync(uploadPath);
    cb(null, uploadPath);
  },
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});

const upload = multer({ 
  storage: storage,
  limits: {
    fileSize: 50 * 1024 * 1024 // 50MB
  }
});

// Health check endpoint
app.get('/health', async (req, res) => {
  try {
    // Check database connection
    await prisma.$queryRaw`SELECT 1`;
    
    // Check Redis connection
    const redisStatus = await redisService.healthCheck();
    
    res.json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      service: 'api-server',
      uptime: process.uptime(),
      memory: process.memoryUsage(),
      services: {
        database: 'connected',
        redis: redisStatus ? 'connected' : 'disconnected',
        googleApi: 'initialized'
      }
    });
  } catch (error) {
    logger.error('Health check failed:', error);
    res.status(503).json({
      status: 'unhealthy',
      timestamp: new Date().toISOString(),
      error: error.message
    });
  }
});

// Health check endpoint (alternative path for compatibility)
app.get('/healthz', async (req, res) => {
  try {
    // Check database connection
    await prisma.$queryRaw`SELECT 1`;
    
    // Check Redis connection
    const redisStatus = await redisService.healthCheck();
    
    res.json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      service: 'api-server',
      uptime: process.uptime(),
      memory: process.memoryUsage(),
      services: {
        database: 'connected',
        redis: redisStatus ? 'connected' : 'disconnected',
        googleApi: 'initialized'
      }
    });
  } catch (error) {
    logger.error('Health check failed:', error);
    res.status(503).json({
      status: 'unhealthy',
      timestamp: new Date().toISOString(),
      error: error.message
    });
  }
});

// Simple test endpoint without any middleware
app.get('/api/simple-test', (req, res) => {
  res.json({ 
    message: 'Server is responding',
    timestamp: new Date().toISOString(),
    path: req.path
  });
});

// Test endpoint with prisma
app.get('/api/test-prisma', async (req, res) => {
  try {
    console.log('ðŸ” [TEST-PRISMA] Testing prisma connection...');
    const tenantCount = await prisma.tenant.count();
    console.log('âœ… [TEST-PRISMA] Tenant count:', tenantCount);
    res.json({ 
      message: 'Prisma is working',
      tenantCount: tenantCount,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('âŒ [TEST-PRISMA] Error:', error);
    res.status(500).json({ 
      error: 'Prisma error',
      message: error.message
    });
  }
});

// Debug endpoint for PersonRole analysis
app.get('/api/debug/person-roles', authenticateToken, tenantMiddleware, async (req, res) => {
  try {
    const tenantId = req.headers['x-tenant-id'] || req.tenantId;
    
    // Get all persons for this tenant
    const persons = await prisma.person.findMany({
      where: {
        tenantId: tenantId,
        deletedAt: null,
        isActive: true
      },
      include: {
        personRoles: {
          where: {
            deletedAt: null,
            isActive: true
          }
        }
      }
    });
    
    // Get all PersonRoles for this tenant
    const allPersonRoles = await prisma.personRole.findMany({
      where: {
        tenantId: tenantId,
        deletedAt: null,
        isActive: true
      }
    });
    
    res.json({
      tenantId,
      personsCount: persons.length,
      personsWithRoles: persons.filter(p => p.personRoles.length > 0).length,
      personsWithoutRoles: persons.filter(p => p.personRoles.length === 0).length,
      totalPersonRoles: allPersonRoles.length,
      persons: persons.map(p => ({
        id: p.id,
        firstName: p.firstName,
        lastName: p.lastName,
        email: p.email,
        rolesCount: p.personRoles.length,
        roles: p.personRoles.map(r => r.roleType)
      })),
      allPersonRoles
    });
  } catch (error) {
    console.error('Debug PersonRole error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Endpoint per contatori dashboard
  app.get('/api/counters', authenticateToken, async (req, res) => {
    try {
      console.log('ðŸ” [COUNTERS] Starting counters endpoint...');
      
      // Ottieni tenantId dall'header o dal token
      const tenantId = req.headers['x-tenant-id'] || req.user?.tenantId;
      
      if (!tenantId) {
        console.error('âŒ [COUNTERS] No tenantId provided');
        return res.status(400).json({ error: 'Tenant ID required' });
      }
      
      console.log('ðŸ” [COUNTERS] Using tenantId:', tenantId);
      
      // Conta le aziende
      const companiesCount = await prisma.company.count({
        where: {
          tenantId: tenantId,
          deletedAt: null,
          isActive: true
        }
      });
      
      // Conta le persone attive (dipendenti)
      const employeesCount = await prisma.person.count({
        where: {
          tenantId: tenantId,
          deletedAt: null,
          status: 'ACTIVE'
        }
      });
      
      const result = {
        companies: companiesCount,
        employees: employeesCount,
        timestamp: new Date().toISOString()
      };
      
      console.log('âœ… [COUNTERS] Result:', result);
      res.json(result);
      
    } catch (error) {
      console.error('âŒ [COUNTERS] Error:', error);
      res.status(500).json({ 
        error: 'Internal server error',
        message: error.message
      });
    }
  });

// Performance dashboard endpoint
app.get('/performance', getPerformanceDashboard);

// Test endpoint
app.get('/test', (req, res) => {
  res.json({ message: 'Test endpoint working', timestamp: new Date().toISOString() });
});

// 404 handler (must be after all routes)
app.use('*', notFoundHandler);

// Global error handler (must be last)
app.use(globalErrorHandler);

// Start server
const startServer = async () => {
  try {
    // Initialize authentication system
    await initializeAuth();
    logger.info('âœ… Authentication system initialized', { service: 'api-server' });
    
    // Initialize Google API Service (optional)
    try {
      await googleApiService.initialize();
      logger.info('âœ… Google API Service initialized', { service: 'api-server' });
    } catch (error) {
      logger.warn('âš ï¸ Google API Service initialization failed, some features may be limited', { 
        service: 'api-server', 
        error: error.message 
      });
    }
    
    // Initialize Redis service
    if (process.env.REDIS_ENABLED !== 'false') {
      await redisService.connect();
      logger.info('âœ… Redis service connected', { service: 'api-server' });
    } else {
      logger.info('â„¹ï¸ Redis disabled, running without cache', { service: 'api-server' });
    }
    
    // Start performance monitoring
    startPerformanceMonitoring();
    logger.info('âœ… Performance monitoring started', { service: 'api-server' });
    
    // Start the server
    const server = app.listen(PORT, '127.0.0.1', () => {
      logger.info('ðŸš€ API Server running successfully', {
        service: 'api-server',
        port: PORT,
        host: '127.0.0.1',
        environment: process.env.NODE_ENV || 'development',
        timestamp: new Date().toISOString()
      });
      logger.info(`ðŸ“ˆ Performance dashboard: http://127.0.0.1:${PORT}/performance`);
    });
    
    return server;
  } catch (error) {
    logger.error('âŒ Failed to start server:', error);
    process.exit(1);
  }
};

// Global server variable
let server;

// Initialize the server
startServer().then(serverInstance => {
  server = serverInstance;
}).catch(error => {
  logger.error('âŒ Failed to start server:', error);
  process.exit(1);
});

// Keep the process alive
process.stdin.resume();

// Graceful shutdown - Configurazione per development/production
if (process.env.NODE_ENV === 'production') {
  process.on('SIGTERM', async () => {
    logger.info('ðŸ”„ SIGTERM received, shutting down gracefully...', { service: 'api-server' });
    
    try {
      await googleApiService.shutdown();
      logger.info('âœ… Google API Service shut down');
      
      await redisService.disconnect();
      logger.info('âœ… Redis connection closed');
      
      if (server) {
        server.close(async () => {
          try {
            await shutdownAuth();
            await prisma.$disconnect();
            logger.info('âœ… API Server shutdown complete', { service: 'api-server' });
            process.exit(0);
          } catch (error) {
            logger.error('âŒ Error during shutdown', { service: 'api-server', error: error.message, stack: error.stack });
            process.exit(1);
          }
        });
      } else {
        process.exit(0);
      }
    } catch (error) {
      logger.error('âŒ Error during shutdown', { service: 'api-server', error: error.message });
      process.exit(1);
    }
  });

  process.on('SIGINT', async () => {
    logger.info('ðŸ”„ SIGINT received, shutting down gracefully...', { service: 'api-server' });
    
    try {
      await googleApiService.shutdown();
      logger.info('âœ… Google API Service shut down');
      
      await redisService.disconnect();
      logger.info('âœ… Redis connection closed');
      
      if (server) {
        server.close(async () => {
          try {
            await shutdownAuth();
            await prisma.$disconnect();
            logger.info('âœ… API Server shutdown complete', { service: 'api-server' });
            process.exit(0);
          } catch (error) {
            logger.error('âŒ Error during shutdown', { service: 'api-server', error: error.message, stack: error.stack });
            process.exit(1);
          }
        });
      } else {
        process.exit(0);
      }
    } catch (error) {
      logger.error('âŒ Error during shutdown', { service: 'api-server', error: error.message });
      process.exit(1);
    }
  });
} else {
  // Development mode: Ignora completamente i segnali SIGINT/SIGTERM
  process.on('SIGTERM', () => {
    logger.info('ðŸ”§ SIGTERM ignored in development mode', { service: 'api-server' });
  });
  
  process.on('SIGINT', () => {
    logger.info('ðŸ”§ SIGINT ignored in development mode', { service: 'api-server' });
  });
  
  logger.info('ðŸ”§ Development mode: SIGINT/SIGTERM signals will be ignored to prevent automatic shutdowns', { service: 'api-server' });
}

export default app;